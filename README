QEPPS: Quadratic eigenvalue problem parameter sweeper
============================================================

Background
------------------------------------
Comsol offers a GUI in which problems can be modeled, meshed, solved, and visualized. This is the way in which most people use the software, however Comsol also supplies a Matlab API exposing most of the features of the GUI so that sequences of operations may be scripted. This API even exposes the solver results, which allows visualization to be performed entirely in Matlab. We have successfully utilized this API in the past to perform advanced parameter sweeps and to automate complex solver sequences that would be extremely tedious in the GUI. The API also exposes Comsol’s internal linear algebra data structures such as the stiffness matrix, mass matrix, force vector, and solution vector. This means that even the underlying linear algebra problem could be solved entirely in Matlab, though no advantage is typically gained by doing this, especially for large problems. 

Comsol does have cluster support with an MPI architecture but requires that Comsol be installed on the cluster. Currently this is not the case for Stampede and the other TACC resources.

Quadratic eigenvalue problems
------------------------------------
Modal studies in electromagnetics are quadratic eigenvalue problems. This means that they can be represented as

(λ^2 * E + λ * D + K)*U = 0

where E, D, and K are matrices, U is the eigenvector, and λ is the eigenvalue. Physically, U corresponds to the electric or magnetic field distribution over the discretized domain, with each element corresponding to one of the field components at a location within the 2D or 3D mesh. λ corresponds to either the mode's guided effective index (in waveguides) or to the bloch wave vector in photonic crystals and other periodic geometries.

In the context of electromagnetics/optics, this parameter to be swept most commonly corresponds to the frequency (equivalently wavelength or color). Sweeping frequency allows for the broadband dispersion of the structure’s mode(s) to be obtained. This is useful for photonic band gap engineering, signal attenuation characterization, and group velocity analysis. 

It would be highly impractical to generate and upload the full E, D, and K matricies for every frequency value of interest, so these matricies will be componentized. This is made possible by a feature of Comsol that was not previously mentioned. Comsol allows the underlying weak form (i.e. the differential equations that are being solved) to be modified. Typically this feature is used to specify some custom physics that isn’t prepackaged by Comsol, but in our case, we use it to factor out the frequency from the various terms in Maxwell’s equations.

Implementation
------------------------------------
The polynomial eigenvalue problem (PEP) context from PETSc/SLEPc 3.5 is used because it provides a scalable mechanism for solving the linear algebra problem. There are a variety of approaches for solving quadratic eigenvalue problems, including direct linearization as well as iterative approaches. PETSc also supports a variety of external solvers such as MUMPS. The solver type in PETSc can be selected and configured at run time via its options database. This approach provides maximal flexibility and good performance.

The LUA open source scripting language, sometimes called an “extension language,” is used to handle the runtime configuration for QEPPS. LUA features a lightweight interpreter with a highly flexible C API. There are two key advantages to be gained by using LUA over command line arguments and flat text files. The first is that we can easily, and programmatically modify the frequency values over which we are sweeping. The second is that we can easily extend our problem space to situations where more complicated functions of frequency appear in our differential equations. In electromagnetics, this is commonly encountered with dispersive materials. QEPPS is implemented to handle inputs of the form,

E = E0*e0(f) + E1*e1(f) + E2*e2(f) + ...

D = D0*d0(f) + D1*d1(f) + D2*d2(f) + ...

K = K0*k0(f) + K1*k1(f) + K2*k2(f) + ...

where Ei, Di, and Ki are component matricies and ei(f), di(f), and ki(f) are arbitrary functions of the sweep parameter. The LUA interpreter handles all function evaluation, eliminating the need to handle string math expression parsing in the compiled code.
